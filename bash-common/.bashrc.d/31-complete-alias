#!/bin/bash
# 31-complete-alias
# aoneill - 11/25/15

# Modified from: http://stackoverflow.com/a/1793178/1450189

function complete_alias() {
  [[ "$1" == "$2" || "$1" == "sudo" ]] && return 1

  local alias_name="$1"
  local aliased_command="$2"
  local alias_arguments="$3"
  local num_alias_arguments=$(echo "$alias_arguments" | wc -w)

  # The completion currently being used for the aliased command.
  local completion=$(complete -p $aliased_command 2> /dev/null)

  # Only a completer based on a function can be wrapped so look for -F
  # in the current completion. This check will also catch commands
  # with no completer for which $completion will be empty.
  if [[ "$(echo $completion | grep -- -F)" == "" ]]
  then
    # Make sure it's not a function
    [[ "$(type -t $aliased_command)" == "function" ]] && return 1

    # All else fails, try to source the completion file
    local file="/usr/share/bash-completion/completions/$aliased_command"
    if [[ -f "$file" && "$(command -v $aliased_command)" != "" ]]
    then
      source $file
      local completion=$(complete -p $aliased_command 2> /dev/null)
      [[ "$(echo $completion | grep -- -F)" == "" ]] && return 1
    else
      return 1
    fi
  fi
  
  local namespace=alias_completion::

  # Extract the name of the completion function from a string that
  # looks like: something -F function_name something
  # First strip the beginning of the string up to the function name by
  # removing "* -F " from the front.
  local completion_function=${completion##* -F }
  # Then strip " *" from the end, leaving only the function name.
  completion_function=${completion_function%% *}

  # Try to prevent an infinite loop by not wrapping a function
  # generated by this function. This can happen when the user runs
  # this twice for an alias like ls='ls --color=auto' or alias l='ls'
  # and alias ls='l foo'
  [[ "${completion_function#$namespace}" != $completion_function ]] && return 0

  if (( $num_alias_arguments > 0 ))
  then
    # Only do this fancy stuff if we need to
    local wrapper_name="${namespace}${alias_name}"

    eval "
function ${wrapper_name}() {
  let COMP_CWORD+=$num_alias_arguments
  args=( \"${alias_arguments}\" )
  COMP_WORDS=( $aliased_command \${args[@]} \${COMP_WORDS[@]:1} )
  $completion_function
}"

    # To create the new completion we use the old one with two
    # replacements:
    # 1) Replace the function with the wrapper.
    local new_completion=${completion/-F * /-F $wrapper_name }
  else
    # Otherwise, just use thedefault completion function
    local new_completion=${completion/-F * /-F $completion_function }
  fi

  # 2) Replace the command being completed with the alias.
  new_completion="${new_completion% *} $alias_name"
  eval "$new_completion"

  return 1
}

eval "$(alias -p | sed -e 's/sudo //g' | sed -e 's/alias \([^=][^=]*\)='\''\([^ ][^ ]*\) *\(.*\)'\''/complete_alias \1 \2 '\''\3'\'' /')"
unset complete_alias
